KWESTIE SILNIKA

	0. WARTE UWAGI MYŒLI
	
		GAME STATE'y - KONIECZNIE
		
		hierarchiczne game staty do wspó³dzielenia danych itp?
		
		nie wszystkie systemy musz¹ chyba updatowaæ siê tak samo czêsto
		
		rozdzieliæ kszta³t i pozycjê
		
		timery dla ka¿dego typu komponentu, który wskazywa³by, ¿e nale¿y je odœwie¿yæ?
		
		dodaæ funkcjê: unsigned string_id(string str), która bêdzie zwraca³a identyfikator dla ka¿dego stringa, tak ¿eby zaoszczêdziæ miejsce czy coœ, no i pewnie optymalizacja
		
		AI: czego nie zna boi siê
		
		------------------------------
		Game:
			- Engine:
				- zawsze w jakimœ State
				- przechowuje Entity oraz Systemy (ale przecie¿ nie wszystkie GameState'y to interesuje, wiêc mo¿e coœ nad Engine - klasa który mo¿e byæ w GameState'ach, np. Game)
			
			- InitialState:
				- od niego zaczynamy
			
			- MainMenuState:
				- po InitialState, albo gdy wychodzimy z gry
			
			- GameplayState:
				Entity sk³ada siê z Componentów.
				SystemNode sk³ada siê z pointerów do Componentów jednego Entity.
				Systemy operuja na SystemNode'ach.
				Engine sk³ada sie z Systemów i wykonuje regularnie ich update (ale przecie¿ render nie jest regularny)
			
			- PauseState:
				- zakrywa GameplayState (zawsze w pamiêci, ale nie na stosie GameState'ów)
			
			- EditState:
				- operuje na tym samym co GameplayState, czyli dane nie nale¿¹ do State'ów, State'y s¹ tylko funkcjami
			
			- ConsoleState(?):
		EntityManager:
			- zawiera fabrykê, graphicsManagera, itd (wszystkie zasoby na które sk³adaj¹ siê byty)
		------------------------------
		
		
		
		w ogóle state'y do wszystkiego (The State Pattern)
		Behaviours bêd¹ potrzebowaæ state'ów - niezupe³nie, bêd¹ potrzebowaæ celów (Planowanie, Akcje, Pre- i Post- conditiony)
		State'y w formie np. ChceJeœæ -> cel: NieChceJeœæ
		
		komponenty przechowywane w systemach jak np. TextureComponent(chocia¿ to powinno byæ bardziej ogólne: GraphiscComponent?) w DisplayManager
		
		nie wywo³ywaæ funkcji innych obiektów, ale wysy³aæ eventy kiedy tylko siê da
		
		atrybuty bytów do zapisywania stanu gry, tworzone przez komponenty (jakaœ mapa?)
		komponenty mog³oby ³atwo dzieliæ siê tymi atrybutami, bez przepytywania swojego Entity o posiadanie jakiegoœ komponentu i w ogóle
		
		id<0 dla archetypów i id>0 dla rzeczywistych obiektów
		# to nie pozwoli przechowywaæ ich wydajnie w tablicy
		
		uchwyty (handle) - dla obiektów w tablicach, ¿eby po indeksach dzia³aæ i optymalizowaæ cache
		
		komponenty maj¹ id swojej "rodziny" oraz swój w³asny id (jeœli mamy jak¹œ hierarchiê wœród komponentów)
		
		czy komponenty maj¹ coœ faktycznie robiæ czy byæ tylko kontenerami?
		
		sendMessage and receiveMessage for both Entities and Components
			
		NotificationSystem - obiekty rejestruj¹ siê do nich, ¿e s³uchaj¹ danych typów wiadomoœci
		albo systemy kontroluj¹ce komponenty rozsy³aj¹ce wiadomoœci do komponentów bez rejestracji
		
		nadawcy i odbiorcy wiadomoœci w pewnych przypadkach
		
		"""
		Also, I did not mention Links yet. Those are a different concept. The engine uses them to link objects together. Basic link type is an inheritance link, which inherits property (component) values from object to other object. There are numerous link types, for example ControlDevice link will route any incomming messages of a certain kind to the object(s) that the link targets, etc. 
		(Imagine a switch linked with a light with ControlDevice link, using the switch will cause a SwitchOn/SwitchOff message to appear, and this message will be routed to the light, which reacts to this signal)
		"""
		
		renderNodes czy coœ w tym stylu
		
		same komponenty sk³adaj¹ siê z czeœci? np. PhysicalForm z³o¿ony z Position, Rotation, "Mesh", Movement - do zmniejszenia rozdrobnienia (nie ka¿dy obiekt potrzebuje kompletnego physical form, niektóre bêd¹ statyczne, inne niewidzialne, albo w ogóle bez kszta³tu i to wszystko w jednym komponencie, ale do tego potrzeba jakiejœ "kompilacji", ¿eby nie traciæ czasu na badanie za ka¿dmy razem z czego sk³ada siê komponent)
		
		Entity::clone()
		
		PhysicalForm mo¿e mieæ stany: Static i Dynamic, które definiuj¹ update (chocia¿ mo¿e nie jest to dobre w tym przyk³adzie)
		
		PhysicalForm = Position [+ Shape] [+ Velocity] [+ Appearance]
		
		dzielone zmienne
		
		
		to jest ciekawe:
		//-----------------------------------------------
		class MoveNode
		{
		  public var position:PositionComponent;
		  public var velocity:VelocityComponent;
		}
		class RenderNode
		{
		  public var display:DisplayComponent;
		  public var position:PositionComponent;
		}
		//-----------------------------------------------
		
		--------------- Jeff Orkin ------------------
		
		animation keyframes with embedded messages to for example: play sound

		cele i akcje, które je zaspokajaj¹ - pewnie jakieœ drzewa gdzie korzeniem jest nasz cel, a ga³êziami drogi do jego zaspokojenia
		nie tam nie bêdzie drzewa, ani w ogóle ¿adnego grafu - tylko warunki wstêpne i skutki, one pozwol¹ na dynamiczne tworzenie scenariuszy, bez ¿adnych zale¿noœci

		A*

		akcje - klasy przechowuj¹ce preconditionale w postaci tablicy ze stanami œwiata oraz funkcjami sprawdzaj¹cymi czy warunki s¹ spe³nione na zawo³anie

		hierarchical task network planning

		hierarchia potrzeb: potrzeby gatunkowe, spo³eczne, lokalne i osobiste
		
		//------------------------------------------------------------------------------------------------------------------------------------//
		
		ScriptSystem jako singleton?
		# teraz ju¿ jest, i jest wewnêtrznie zupe³nie niezale¿ny od ca³ej reszty programu

##############################################################################################################################
	1. G£ÓWNE CELE:
	
		# SERIALIZACJA I SKRYPTY - Lua
		
		# konsola nie powinna ingerowaæ w g³ówn¹ pêtlê gry (albo usprawniæ t¹ drug¹, ¿eby sobie z tym radzi³a)
		
		# tak czy siak trzeba usprawniæ g³ówn¹ pêtlê
		
		# eventy zmieniaj¹ STAN obiektów(komponentów), co jest obs³ugiwane w g³ównej pêtli update'ów
	
		# funkcja dla ka¿dego Entity buduj¹ca jego funkcjê update(unsigned ms_passed) z jego komponentów (generuje automatycznie powi¹zania miêdzy komponentami, by oby³o siê bez sprawdzania za ka¿dym razem czy entity ma jakiœ komponent) - rebuild()
			to ju¿ na poziomie skryptów

		# USPRAWNIÆ KOMUNIKACJÊ MIÊDZY SYSTEMAMI (mniej przekazywania systemów - niech siê znaj¹, ale te¿ ¿eby by³y w miarê niezale¿ne od siebie, bo czym mniej znajomoœci tym lepiej, nie?)
		
		# BEZ SPRAWDZANIA CZY KOMPONENT JEST W ENTITY WYWO£YWAÆ FUNKCJÊ TYCH KOMPONENTÓW
			A MO¯E TRZEBA ZMIENIÆ METODYKÊ, ¯EBY TAKICH SYTUACJI W OGÓLE NIE BY£O
		
		funkcja typu: entity.run(SomeComponent, someFunction, arg1, arg2, ...)
				  albo:	run(entity, SomeComponent, someFunction, arg1, arg2, ...)	

		sprawdza czy entity ma dany komponent i jeœli tak to wykonuje na nim funkcjê
		zamiast 
		
		if(entity->hasComponent<someComponent>())
			entity->getComponent<someComponent>->someFunction(arg1, arg2, ...)
		
		to nie jest takie proste, bo te funkcje te¿ zwracaj¹ wartoœci
		
		funkcje a procedury
			
		albo po prostu zrobiæ obs³ugê wyj¹tków - gdy nie ma komponentu rzuca wyj¹tek i po sprawie, tylko ¿e ca³y kod trzeba by przebudowaæ, to i tak trzeba jakoœ inaczej
		mo¿e funkcja z lambd¹ jako argumentem a w niej operacje, które maj¹ siê wykonaæ 
		
		# rozbudowaæ obs³ugê zdarzeñ (ale do tego potrzeba przekontruowaæ czêœæ silnika - uproœciæ komunikacjê miêdzy systemami, itp)

		# OBS£UGA WYJ¥TKÓW (mniej crashy, prostszy kod)
		
	2. WA¯NE:
	
		# zrobiæ porz¹dek z tymi vector2d
	
		# ObjectFactory tworz¹cy obiekty z serializacji ("poprzez serializacjê"?)
			
		# dodaæ system obiektów bazowych i ich instancji
	
		# funkcja getComponent powinna wyrzucaæ wyj¹tek przy próbie uzyskania komponentu którego nie ma zamiast zwracaæ nullptr - tylko ¿e z tym jest problem, bo trzeba wszêdzie pamiêtaæ, ¿e to pluje wyj¹tkami które trzeba obs³u¿yæ, a wywo³añ getComponent jest ca³a masa
	
		# rozszerzyæ/przebudowaæ komponent TextureComponent, tak by mo¿na by³o u¿ywaæ animacji

		# wszystkie systemy dziedzicz¹ z jednego metasystemu i maj¹ listê systemów od których s¹ zale¿ne, a ich aktywnoœæ jest sprawdzana przy wywo³aniu isActive() (³atwiejsza rozbudowa)

		# OCZYŒCIÆ KOD
		
		# wydajniejsze przechowywanie obiektów gry
		
	3. ŒREDNIO WA¯NE:
	
		# DWIÊK
	
		# obs³uga tekstu
	
		# dodaæ kamerê - jako klasa powinna byæ jednakowa w ka¿dym projekcie, ale jej obs³uga to ju¿ kwestia ka¿dego przypadku z osobna (skrypty)
	
		# zacz¹æ wprowadzaæ jakiœ standard (komponenty, których nie powinno siê zastêpowaæ - zupe³nie podstawowe jak PhysicalForm, TextureComponent i pewnie coœ jeszcze)
		
	4. MA£O WA¯NE:
	
		# zredukowaæ liczbê wywo³añ printf()

		# multimapy do przechowywania komponentów? - "optymalizacja" przy korzystaniu z systemow

		
KWESTIE GRY

	1. WA¯NE:
	
		# optymalizacja le¿y i kwiczy - jeden przeciwnik z¿era 100fps'ów
	
	2. ŒREDNIO WA¯NE:
	
		# ulepszyc AI - sprawiæ by przestali sie zatrzymywac bez powodu
	
		# przebudowaæ sterowanie na bardziej elastyczne (wiêcej fizyki, mniej logiki)
	
		# power-up'y
		
		# dodaæ jakiœ cel/nastêpne poziomy/zbieranie kluczy
	
	3. MA£O WA¯NE:

		# jakies menu czy cos, bo bez to lipa troche
		
		