#include "Engine.h"

#include <SDL.h>
#include <stdio.h>

#include "Structures.h"

#include <ctime>
#include <cstdlib>

#include "DisplayManager.h"
#include "EntityManager.h"
#include "EventManager.h"
#include "ScriptSystem.h"
#include "Console.h"
/// TEST
#include "ComponentSystem.h"
#include "GameInitializer.h"

#include "setups.h"
///
bool Engine::paused = false;

Engine &Engine::getInstance() {
    static Engine instance;
    return instance;
}

Engine::Engine() {
    logs::open("creating GameInstance...");

    displayManager = new DisplayManager(this);
    entityManager = new EntityManager();
    eventManager = new EventManager(this);
    console = new Console(this);
    componentSystem = new ComponentSystem();

    scriptSystem = new ScriptSystem();

    working = true;

    logs::close("done\n");
}

Engine::~Engine() {
    logs::open("delete GameInstance\n");

    SDL_RemoveTimer(timerID);

    delete eventManager;
    delete displayManager;
    delete componentSystem;
//    delete logicManager;
    delete entityManager;
    delete console;

    delete scriptSystem;

    SDL_Quit();
    logs::close("GAME CLOSED!");
}

int Engine::run() {
    if(init() < 0) {
        return -1;
    }

    srand(time(NULL));

    unsigned last_check = SDL_GetTicks();
    unsigned frames = 0;
    unsigned previous = SDL_GetTicks();
    unsigned last_update = SDL_GetTicks();
    unsigned lag = 0.0;

    while(working) {
        unsigned current = SDL_GetTicks();
        unsigned elapsed = current - previous;

        previous = current;

        eventManager->handleEvents();
        console->run(); /// tu trzeba statÃ³w

        if(!paused) {
            lag += elapsed;
            while (lag >= TIMESTEP) {
                entityManager->update();
                componentSystem->update(TIMESTEP, entityManager);
                Engine::instance()->getScriptSystem()->update(TIMESTEP);
                lag -= TIMESTEP;
                last_update = SDL_GetTicks();
            }
        }

        displayManager->render(entityManager, double(SDL_GetTicks() - last_update) / TIMESTEP);
        frames++;

        if(SDL_GetTicks() - last_check >= 1000) {
            logs::log("FPS: %d\n",frames);
            frames = 0;
            last_check = SDL_GetTicks();
        }

        SDL_Delay(1); /// tylko do testow
    }
    return 0;
}

/*
void GameInstance::run()
{
    gameStates.push_back(new MainMenuGS());

}
*/
int Engine::init() {
    if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER) < 0) {
        logs::log("SDL could not initialize! SDL_Error: %s\n", SDL_GetError());
        return -1;
    }

    console->init();
    displayManager->init();
    componentSystem->init();

    if(!(
                displayManager->isActive()    &&
                entityManager->isActive()     &&
//         logicManager->isActive()      &&
                eventManager->isActive()      &&
                Engine::instance()->getScriptSystem()->isActive()
            )) {
        logs::log("some systems are not active\n");
        return -1;
    }

    EventManager::registerEventCallback(SDL_QUIT, [=](SDL_Event const& event) {
        quit();
    });

    EventManager::registerEventCallback(SDL_USEREVENT, [=](SDL_Event const& event) {
        SDL_Event pushed;
        switch (event.user.code) {
        case EVENT_LOST:
            logs::log("EVENT_LOST\n");
            SDL_memset(&pushed, 0, sizeof(pushed));
            pushed.type = SDL_QUIT;
            SDL_PushEvent(&pushed);
            break;
        case EVENT_WON:
            logs::log("EVENT_WON\n");
            SDL_memset(&pushed, 0, sizeof(pushed));
            pushed.type = SDL_QUIT;
            SDL_PushEvent(&pushed);
            break;
        case EVENT_PAUSE:
            tooglePause();
            break;
        }
    });

    EventManager::registerEventCallback(SDL_KEYDOWN, [=](SDL_Event const& event) {
        SDL_Keycode keycode = event.key.keysym.sym;
        switch (keycode) {
        case SDLK_ESCAPE:
            SDL_Event pushed;
            pushed.type = SDL_QUIT;
            SDL_PushEvent(&pushed);
            break;
//        case SDLK_p:
//            EventManager::pushUserEvent(EVENT_PAUSE,NULL,NULL);
//            break;
        case SDLK_BACKQUOTE:
            EventManager::pushUserEvent(EVENT_CONSOLE_TOGGLE,NULL,NULL);
            break;
        }
    });

//    comp_setup::register_components();
    setups::register_all();
    //Entity::setup();

    GameInitializer().init_entities(entityManager);

    /// TEST TIMERA
    /*
    Uint32 delay = 1000;
    SDL_TimerID my_timer_id = SDL_AddTimer(delay,
        [=](Uint32 interval, void *param) -> int
        {
            EventManager::pushUserEvent(EVENT_CONSOLE_TOGGLE,NULL,NULL);

            return(interval);
        }, NULL);
    */
    return 0;
}

void Engine::quit() {
    working = false;
}

DisplayManager  *Engine::getDisplayManager() {
    return displayManager;
}
EntityManager   *Engine::getEntityManager() {
    return entityManager;
}
//LogicManager    *GameInstance::getLogicManager(){return logicManager;}
Console         *Engine::getConsole() {
    return console;
}
EventManager    *Engine::getEventManager() {
    return eventManager;
}
