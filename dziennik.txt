16.05.2017
	1. mrówki chodzą do ziaren, zbierają je, ale póki co jest sieczka
	2. nie chce mi się naprawiać, ale kilku może nosić ten sam obiekt, a nawet jak ktoś nosi, to cały czas wywołuje to kolizje - masakra
	3. zrobić żeby chodzili za tym co w followed_scent
17.05.2017
	1. dziwne zamieszanie - część mrówek z późniejszego okresu zatrzymuje się w połowie drogi i krążą w miejscu
	2. MYŚLEĆ NAD IMPLEMENTACJĄ AKCJI
	3. akcje kumulacyjne - jeśli nie można zrobić czegoś za jednym zamachem, robimy to co najbardziej nas przybliży do celu
	4. warto przeanalizować to dokładnie: https://gamedevelopment.tutsplus.com/tutorials/goal-oriented-action-planning-for-a-smarter-ai--cms-20793
	5. olać "węch" - uprościć, żeby szybko wprowadzić pierwszy, prosty GOAP
	6. Idle, GoTo, PerformAction
18.05.2017
	1. dodałem obiekty, ale bez implementacji metod, ani w ogóle wszystkich metod... ale wszystkie obiekty potrzebne chyba są
19.05.2017
	1. jakieś funkcje, które testują "WorldSpace" i ustawiają odpowiadające wartości w WorldState
	3. dla lepszej heurystyki ustalić jakiś tam koszt zmiany każdego stanu?
	4. i jednak od końca
20.05.2017
	1. zrobić, żeby czujniki ustawiały wartości w WorldState'ach - chyba po jednym na każdą zmienną
	2. pierwszy GOAPPlanner zaimplementowany - ciekawe tylko czy działa
	3. planner chyba działa, przynajmniej na tym jednym przykładzie
	4. teraz zrobić ActionHandler'y lub coś, które mają:
		- ustalać cel akcji
		- sprawdzać preconditionale
		- ewentualnie ustalać koszt (wspomagać plannera)
		- sterować wykonaniem akcji
	5. jak zrobić ustalanie celów?
	6. kiedyś tam pewnie przyda się uogólnienie tego A*... chociaż pewnie prościej będzie przepisać go dla nowego użytku... chociaż kiedyś może...
	7. stworzyć PACZKI z dostępnymi akcjami dla AI
	8. oraz definicje akcji... może Lua w końcu się przyda?
21.05.2017
	1. stany porządane określające cele: "jestem zdrowy", "jestem bezpieczny" itp...
	2. dodać funkcję move_towards()
	3. zredukować to rozdrobnienie komponentów, bo to chore i utrudnia tylko
	4. przemianować CPhysicalForm na Transform
26.05.2017
	1. zrobić żeby akcje jako takie były w tylko jednym miejscu, a byty posiadały jedynie jakieś łączniki wskazujące, że potrafią je wykonywać, ewentualnie jakieś dane w tych łącznikach jeśli potrzeba (o celu itp) ActionHandle/ActionLink
28.05.2017
	1. stworzyć jakaś pamięć "krótkotrwałą" która zapamiętywałaby, które akcje się nie powiodły tak by planista nie próbował robić ciągle tego samego przy niepowodzeniu
	2. OPRACOWAĆ MECHANIZMY POZWALAJĄCE NA CZYSZCZENIE - USUWANIE OBIEKTÓW, ICH KOMPONENTÓW ITP.
	3. no miło - mrówki chodzą w tę i z powrotem, ale nic z tego nie wynika, zrobić żeby nosiły ziarna i odkładały je
	4. dodać jakieś ActionNode'y - pole na które się wchodzi i można wykonywać tam akcję na targecie
	5. co jeśli któraś mrówka zabierze się za podnoszenie ziarna, które chciała podnieść inna?
29.05.2017
	1. DANE w jakimś JSONie lub czymś nawet lżejszym
	2. podstawowy json dodany - akcje z pliku
	4. jakieś wygodne narzędzie do generowania jsonów
	5. przebudować wszystkie komponenty na mapy przechowujące dowolne dane?
	6. definiowanie obiektów jednak poprzez skrypty
	7. przerzucić make_entity i make_component do ObjectFactory zamiast EntityManagera
	8. żeby każda akcja składała się z (niepodzilnych, atomowych) czynności, które sprawiają zmiany w worldstate?
	9. ciekawe:
		template <typename T, typename... Ts>
		void Push(const T value, const Ts... values) {
			Push(value);
			Push(values...);
		}
31.05.2017
	1. pozbyć się GotoState i zastąpić go zwykłą akcją?
	2. klasa Systems/States czy coś w tym stylu przechowująca systemy i ich stany, zwraca instancje aktualnego systemu
	3. MUS NAPRAWIĆ USUWANIE OBIEKTÓW
	4. stworzyć coś specjalnego dla komponentów? by usuwać je automatycznie zewsząd kiedy ginie entity - np. klasa dziedzicząca z shared_ptr, która przy counterze==0 usuwa wpis z tablicy komponentów
		albo po prostu usuwać martwe pointery przy wykryciu...
	5. trzeba usuwać te martwe komponenty bo crashe
	6. remember: BULLET-PROOF CODE
	7. ciekawe, że jak dochodzą do celu a okazuje się że celu nie ma to szukają na nowo :D
	8. entity umierając powinien zadbać że jego komponenty znikną
	9. crashe są jak więcej niż jeden czeka na zakończenie akcji na tym samym targecie - tak to jest duży problem
		edit: po poprawce albo gość się zapętla, albo crash
	10. wrócić do obmyślania entitów na nowo, żeby to usuwanie działało.
02.06.2017
	1. komponenty się teoretycznie usuwają
	2. nie wiem co powoduje te crashe, ale to ma związek z usuwaniem obiektów
	3. nadal dwaj mogą usunąć ten sam obiekt w "skypcie" akcji - wina tego, że nie usuwam obiektu od razu... to by trzeba jakoś naprawić
	4. LOGI W osobnym wątku, by nie spowalniać aplikacji
	5. przywrócić deaktywację entity'ów?
	6. ten mechanizm, który dla każdego stringa zwraca jego id by się przydał - do wszystkiego praktycznie
	7. jakieś "wyłączanie" i komponentów i entity'ów zrobić zanim je usuwamy z pamięci, tylko... jak zrobić to wydajnie? najlepiej tak żeby nie było ich po prostu widać
		może listy z identyfikatorami aktywnych, a same komponenty w ciągłej pamięci...
		nie to chyba nie jest dobry pomysł
	8. prawdopodobnie będzie trzeba myśleć jeszcze raz o pozyskiwaniu komponentów z entity'ów:
		"I've seen a library (Ashley, java-based) use bits for component types implementation. 
		It seems clever since it allows to make complex component type tests in a pretty optimized way (e.g. does this entity have type A, B & C = one bitwise & operation, as long as you have <64 component types).
	9. ale tą deaktywację, a dopiero potem garbage collector trzeba zrobić...
03.06.2017
	1. jakiś rodzaj SmartPointera? trzymanie syrowych identyfikatorów też jest niefajne, bo weźmy sytuację: entity jest celem jakieś akcji, jego id jest trzymany przez drugie entity, którą tą akcję na nim wykonuje, entity #1 znika, jego id jest wrzucone do worka i zaraz po tym inny obiekt stworzyny dostaje jego id i akcja zostaje wykonana na innym obiekcie
	2. pozbyć się type_index (edit. chyba się nie da)
	3. chyba pozbyłem się crashy w trakcie, ale za to pojawiły się crashe na koniec: dodałem do każdego entity bool'a aktywności
	4. przeniosłem część wykonania akcji na skrypty, teraz tylko to usprawnić i doprowadzić do porządanego stanu
	5. następny krok - przenieść definicje bytów do skryptów, by można stworzyć edytor
04.06.2017
	1. utworzyć paczki zachowań (np. utrzymywanie przy życiu, praca jako ktoś, walka itd), które będą przekazywane konstruktorowi GoapAgenta i to będzie ładne, tylko że każda klasa bytów musi mieć własną implementację zachowań (np. pozyskiwanie pożywienia przez roślinożerców i mięsożerców, mimo że z zewnątrz to będzie po prostu "pozyskiwanie pożywienia")
	2. funkcje zwracające funkcje przy wykonywaniu akcji przez skrypty
	3. myśleć nad wielowątkowością?
	4. funkcje update'ujące wykonanie akcji muszą przyjmować wykonawce, cel oraz czas, który upłynął
	5. std::remove_if - dla garbage collectora
05.06.2017
	trzeba przebudować tak żeby przerzucać raw pointery do Lua'y
06.06.2017
	zmienić główną pętlę na bardziej singlową niż multikową
	logika za akcjami wrzucona całkowicie do skryptów, jestem ciekaw jak będzie z wydajnością - ale to nie jest do końca fajne
	dodać w jakiś sposób szukanie nowych celów jeśli gonienie za aktualnym trwa za długo
	no grubo HeapCorruptionException - to pewnie przez Lua'e... czasem jest to, a czasem zamyka się ładnie
	pozbyć się tego lagu kiedy tracą target
	mniej regularne checki czy cel jest nadal aktywny... to by trzeba jednak iść za punktem a nie Entity'em konkretnym.... to późnej
	dodać te "procedural precondition checkers"
	jakiś wygodniejszy sposób generowania tych wrapperów - najlepiej żeby pominąć je, a robić tylko własciwe funkcje... tylko jak wtedy z tymi zmiennymi tworzonymi we wrapperze?
09.06.2017
	nie wiem jak rozwiązać tworzenie komponentów po stronie Lua'y
!	czy w ogóle te smart pointery mają sens w tym projekcie? no okej, mają... chociaż pewnie gdyby konstrukcja systemu była lepsza to by potrzebne nie były
10.06.2017
	jakiś komponent "Automat", który by po prostu cały czas działał jakimś skryptem
13.06.2017
	zmienić podejście do skryptów AI
	zminiłem, ale nie wiem czy to nie utrudni pracy (chociaż no skrypty wyglądają ładniej)
	zrobić, żeby GotoState ustawiał tylko prędkości, a samo poruszanie było już na zewnątrz
!	zdaje się że jest jakiś drobny wyciek pamięci
	zamiast pickup/deliver grain/water -> deliver resource. chociaż nie, to zbyt abstrakcyjne dla planisty, nie wiem jak to zaprogramować póki co
!	HEAPCORRUPTION NADAL SIĘ POJAWIA
14.06.2017
!	inaczej rozwiązać poruszanie się AI, bo nie wszystkie akcje wymagają poruszania się do celu by coś stojąc zrobić, niektóre to ruch sam w sobie (uciekanie przed czymś) lub powinny być wykonywane w ruchu
	poruszanie się powinno być przezroczyście wpecione w AI nie jako osobny stan
	zmerge'ować GotoState z PerformActionState...
	a może jeszcze inaczej - wpleść w same skrypty
15.06.2017
	komponenty skupiające inne komponenty? np. ogólna "fizyczność" na którą składałyby się Transformation, RigidBody, Aspect, Movement, Mass(?) itp.
	odrobina dziedziczenia w komponentach DynamicBody, StaticBody, KinematicBody
17.06.2017
	dodać jakieś wagi do worldstate'ów czy coś żeby np. zaznaczyć poziom głodu, że jeszcze nie jest aż tak duży można zająć się czymś innym, ale jeśli będzie za duży to nie ma wyboru trzeba jeść
+	scannery w aktualnej formie nie mają odpowiedniego zasięgu (tylko agent) (DOSTĘP Z POZIOMU SKRYPTÓW DO WSZYSTKICH OBIEKTÓW) +++ naprawiane przez rejestrację Engine'u do Lua'y
	zrobić żeby przestali chodzić gdy nie potrzeba
+	naprawić ten heapcorruption
	jak zrobić żeby mrówka była jedzeniem ale żeby mrówki jej nie jadły, tylko potwór?
	JAKAŚ HIERARCHIA W ACTIONHANDLERZE? żeby różną ilość argumentów przyjmowały czy coś
	naprawić "beztargetowe" akcje
	rzadko są głodni, a zmęczeni to już wcale
18.06.2017
	akcje akcjami, ale handlery powinny być jakoś osobno, bo inaczej jada wilk, a inaczej owca
+	HeapCorruptionException oczywiście przed usuwaniem ScriptSystemu
	tego jsona "objects.json" trzeba przeparsować tak aby tworzyć jakieś szkielety obiektów, a potem tylko je instancjonować
	ZBUDOWAĆ JAKIŚ ŁADNY SYSTEM DLA LOGÓW
	okej, praktycznie wszystko kontekstowe przeniesione do skryptów
	chyba popełniam błąd wyrzucając to wszystko poza główny kod już teraz...
+++	NIEBEZPOŚREDNI DOSTĘP DO SKRYPTÓW - w ScriptSystem mapa <string, LuaRef> przez nią odwołania... tylko czy to nie spowolni aż za bardzo?
19.06.2017
++	skrypty akcji muszą przyjmować deltę czasu
	jak ustawić niestandardowe parametry?
	do definicji dodać coś w stylu "base" który przechowywałby nazwę typu(typów) który ten dany rozszerza... tylko że to nie jest takie łatwe (to potem)
20.06.2017
!	DODAĆ DO DEFINICJI OBIEKTÓW ODNOŚNIK DO SKRYPTU INICJALIZUJĄCEGO ODPOWIEDNIE WARTOŚCI - to chyba dotyczyło CProperties itp
	niech skrypt akcji decyduje czy trzeba chodzić + jak to robić
	różne skrypty do wykonywania akcji dla różnych typów obiektów? za dużo roboty żeby to wszystko na gołych danych parować - trzeba narzędzia i "bazy danych"
###	STWORZYĆ NARZĘDZIE UMOŻLIWIAJĄCE TWORZENIE I EDYCJĘ DANYCH (w tym skryptów - prosty edytor) I PRZEDE WSZYSTKIM DAJĄCE CZYTELNY POGLĄD NA WSZELKIE POWIĄZANIA
!	rekalkulacja priorytetów - jakiś skrypt dla każdego info o świecie - nowe dane, które trzeba sformalizować i potworzyć
++	sensory sprawdzające warunki dla wykonania akcji to jedno, a sensory skanujące świat i ustawiające worldstaty to drugie
21.06.2017
!!!	od nowa zaimplementować wykonywanie akcji żeby nie było GotoState bo zmusza do różnych dziwnych sztuczek i strasznie ogranicza
	dane o celu trzymać po stronie Lua'y? bo to w sumie jest dość zależne od samej akcji, nie wszystkie muszą mieć cel
	jakiś dynamiczny system indeksowania obiektów, czy chociaż kategorii żeby poszukiwanie celów było szybsze - czy coś
!	zredukować użycie smart pointerów
nie wiem co ja tu robię...
!!! potrzeba jakiś zmiennych do sterowania skryptami po stronie Lua'y
29.06.2017
++	trochę przebudowałem cały system, powinno być wygodniej
++	pozbyłem się też wszelkich crashy przy zamykaniu (nie ma już heap corruption exception ani nic)
	OBOWIĄZKI I CZAS WOLNY
++	akcje to już tylko dane - nie mają żadnego związku z "posiadaczem"
	gdzie umieścić poruszanie się, żeby nie trzeba do każdego skryptu tego wciskać? ale zarazem żeby nie było tak jak wcześniej, czyli sztywny GotoState...
	akcje wykonywane w ruchu...
#	z tymi różnymi skryptami do wykonywania akcji przez każdy typ bytu to trochę przesada - tak na dobrą sprawę to chodzi po prostu o inną animację w większości przypadków, bo w reszcie to już po prostu inna akcja
	po prostu wpleść gdzieś minimalny zasięg i wykonywać, gdy jest w zasięgu...
	zasięg zależy od "narzędzia"
#	hmm... zasięg dłoni, kija, miecza, dzidy, grabii, toporka, łuku...
##	skrypt wykonywać nawet jeśli poza zasięgiem - może to nie być potrzebne, albo jakaś reakcja gdy jest poza zasięgiem, lub zrobienie czegoś w czasie podchodzenia
	to może być to.
##	za poruszanie się i tak będą odpowiadać skrypty... jakieś style poruszania się czy coś - osobna kategoria skryptów? hmmm... chyba tak
	nadal widzę miejsce dla tych "mikroakcji"...
##	jakiś rodzaj niezależnej od głównego Goap'a warstwy AI, która odpowiadałaby za różne podstawowe czynności jak np. chodzenie, odbieranie czynników, skanowanie otoczenia?
30.06.2017
	może kiedyś się całość AI przeniesie do skryptów - mniej skakania między C++ a Luą
####	"NARZĘDZIA": można "nauczyć" ich obsługi narzędzi, a akcje będą wykonywać wtedy już "instyktownie", jak np. "użyj dłoni/widelca/dzidy (wszystkie dają możliwość przemieszczania obiektów o pewnych własnościach, tzn. "miekkich") by umieścić pokarm w ustach", skrypt ogranicza się wtedy do "użyj narzędzia by umieścić pokarm w ustach", a jakie to narzędzie to będzie to już nie ważne
	można będzie po prostu dodawać narzędzia, uczyć obsługi (która też będzie w wielu przypadkach powieleniem jednego skryptu lub drobny dostosowaniem do konkretnego warunku)
	czy CELE akcji potrzebują też takich pojęć? na razie nie wiem
	łączenie narzędzi: ręka trzyma miecz/widelec
01.07.2017
	nie zaśmiecać skryptów rzeczami typu "idź tam", tylko wykonanie akcji - a to czy wykonywana być może powinno być zdecydowane wyżej
###	intrumenty udostępniają interfejsy typu: "złap", "przenieś", "rzuć" itp?
