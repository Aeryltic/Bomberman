16.05.2017
	1. mrówki chodz¹ do ziaren, zbieraj¹ je, ale póki co jest sieczka
	2. nie chce mi siê naprawiaæ, ale kilku mo¿e nosiæ ten sam obiekt, a nawet jak ktoœ nosi, to ca³y czas wywo³uje to kolizje - no masakra
	3. zrobiæ ¿eby chodzili za tym co w followed_scent
17.05.2017
	1. dziwne zamieszanie - czêœæ mrówek z póŸniejszego okresu zatrzymuje siê w po³owie drogi i kr¹¿¹ w miejscu
	2. MYŒLEÆ NAD IMPLEMENTACJ¥ AKCJI
	3. akcje kumulacyjne - jeœli nie mo¿na zrobiæ czegoœ za jednym zamachem, robimy to co najbardziej nas przybli¿y do celu
	4. warto przeanalizowaæ to dok³adnie: https://gamedevelopment.tutsplus.com/tutorials/goal-oriented-action-planning-for-a-smarter-ai--cms-20793
	5. olaæ "wêch" - uproœciæ, ¿eby szybko wprowadziæ pierwszy, prosty GOAP
	6. Idle, GoTo, PerformAction
18.05.2017
	1. doda³em obiekty, ale bez implementacji metod, ani w ogóle wszystkich metod... ale wszystkie obiekty potrzebne chyba s¹
19.05.2017
	1. jakieœ funkcje, które testuj¹ "WorldSpace" i ustawiaj¹ odpowiadaj¹ce wartoœci w WorldState
	3. dla lepszej heurystyki ustaliæ jakiœ tam koszt zmiany ka¿dego stanu?
	4. i jednak od koñca
20.05.2017
	1. zrobiæ, ¿eby czujniki ustawia³y wartoœci w WorldState'ach - chyba po jednym na ka¿d¹ zmienn¹
	2. pierwszy GOAPPlanner zaimplementowany - ciekawe tylko czy dzia³a
	3. planner chyba dzia³a, przynajmniej na tym jednym przyk³adzie
	4. teraz zrobiæ ActionHandler'y lub coœ, które maj¹:
		- ustalaæ cel akcji
		- sprawdzaæ preconditionale
		- ewentualnie ustalaæ koszt (wspomagaæ plannera)
		- sterowaæ wykonaniem akcji
	5. jak zrobiæ ustalanie celów?
	6. kiedyœ tam pewnie przyda siê uogólnienie tego A*... chocia¿ pewnie proœciej bêdzie przepisaæ go dla nowego u¿ytku... chocia¿ kiedyœ mo¿e...
	7. stworzyæ PACZKI z dostêpnymi akcjami dla AI
	8. oraz definicje akcji... mo¿e Lua w koñcu siê przyda?
21.05.2017
	1. stany porz¹dane okreœlaj¹ce cele: "jestem zdrowy", "jestem bezpieczny" itp...
	2. dodaæ funkcjê move_towards()
	3. zredukowaæ to rozdrobnienie komponentów, bo to chore i utrudnia tylko
	4. przemianowaæ CPhysicalForm na Transform
26.05.2017
	1. zrobiæ ¿eby akcje jako takie by³y w tylko jednym miejscu, a byty posiada³y jedynie jakieœ ³¹czniki wskazuj¹ce, ¿e potrafi¹ je wykonywaæ, ewentualnie jakieœ dane w tych ³¹cznikach jeœli potrzeba (o celu itp) ActionHandle/ActionLink
28.05.2017
	1. stworzyæ jakaœ pamiêæ "krótkotrwa³¹" która zapamiêtywa³aby, które akcje siê nie powiod³y tak by planista nie próbowa³ robiæ ci¹gle tego samego przy niepowodzeniu
	2. OPRACOWAÆ MECHANIZMY POZWALAJ¥CE NA CZYSZCZENIE - USUWANIE OBIEKTÓW, ICH KOMPONENTÓW ITP.
	3. no mi³o - mrówki chodz¹ w tê i z powrotem, ale nic z tego nie wynika, zrobiæ ¿eby nosi³y ziarna i odk³ada³y je
	4. dodaæ jakieœ ActionNode'y - pole na które siê wchodzi i mo¿na wykonywaæ tam akcjê na targecie
	5. co jeœli któraœ mrówka zabierze siê za podnoszenie ziarna, które chcia³a podnieœæ inna?
29.05.2017
	1. DANE w jakimœ JSONie lub czymœ nawet l¿ejszym
	2. podstawowy json dodany - akcje z pliku
	3. mo¿na by jeszcze zmniejszyæ jsona
	4. jakieœ wygodne narzêdzie do generowania jsonów
	5. przebudowaæ wszystkie komponenty na mapy przechowuj¹ce dowolne dane?
	6. definiowanie obiektów jednak poprzez skrypty
	7. przerzuciæ make_entity i make_component do ObjectFactory zamiast EntityManagera
	8. ¿eby ka¿da akcja sk³ada³a siê z (niepodzilnych, atomowych) czynnoœci, które sprawiaj¹ zmiany w worldstate?
	9. ciekawe:
		template <typename T, typename... Ts>
		void Push(const T value, const Ts... values) {
			Push(value);
			Push(values...);
		}
31.05.2017
	1. pozbyæ siê GotoState i zast¹piæ go zwyk³¹ akcj¹?
	2. klasa Systems/States czy coœ w tym stylu przechowuj¹ca systemy i ich stany, zwraca instancje aktualnego systemu
	3. MUS NAPRAWIÆ USUWANIE OBIEKTÓW
	4. stworzyæ coœ specjalnego dla komponentów? by usuwaæ je automatycznie zewsz¹d kiedy ginie entity - np. klasa dziedzicz¹ca z shared_ptr, która przy counterze==0 usuwa wpis z tablicy komponentów
		albo po prostu usuwaæ martwe pointery przy wykryciu...
	5. trzeba usuwaæ te martwe komponenty bo crashe
	6. remember: BULLET-PROOF CODE
	7. ciekawe, ¿e jak dochodz¹ do celu a okazuje siê ¿e celu nie ma to szukaj¹ na nowo :D
	8. entity umieraj¹c powinien zadbaæ ¿e jego komponenty znikn¹
	9. crashe s¹ jak wiêcej ni¿ jeden czeka na zakoñczenie akcji na tym samym targecie - tak to jest du¿y problem
		edit: po poprawce albo goœæ siê zapêtla, albo crash
	10. wróciæ do obmyœlania entitów na nowo, ¿eby to usuwanie dzia³a³o.
02.06.2017
	1. komponenty siê teoretycznie usuwaj¹
	2. nie wiem co powoduje te crashe, ale to ma zwi¹zek z usuwaniem obiektów
	3. nadal dwaj mog¹ usun¹æ ten sam obiekt w "skypcie" akcji - wina tego, ¿e nie usuwam obiektu od razu... to by trzeba jakoœ naprawiæ
	4. LOGI W osobnym w¹tku, by nie spowalniaæ aplikacji
	5. przywróciæ deaktywacjê entity'ów?
	6. ten mechanizm, który dla ka¿dego stringa zwraca jego id by siê przyda³ - do wszystkiego praktycznie
	7. jakieœ "wy³¹czanie" i komponentów i entity'ów zrobiæ zanim je usuwamy z pamiêci, tylko... jak zrobiæ to wydajnie? najlepiej tak ¿eby nie by³o ich po prostu widaæ
		mo¿e listy z identyfikatorami aktywnych, a same komponenty w ci¹g³ej pamiêci...
		nie to chyba nie jest dobry pomys³
	8. prawdopodobnie bêdzie trzeba myœleæ jeszcze raz o pozyskiwaniu komponentów z entity'ów:
		"I've seen a library (Ashley, java-based) use bits for component types implementation. 
		It seems clever since it allows to make complex component type tests in a pretty optimized way (e.g. does this entity have type A, B & C = one bitwise & operation, as long as you have <64 component types).
	9. ale t¹ deaktywacjê, a dopiero potem garbage collector trzeba zrobiæ...
03.06.2017
	1. jakiœ rodzaj SmartPointera? trzymanie syrowych identyfikatorów te¿ jest niefajne, bo weŸmy sytuacjê: entity jest celem jakieœ akcji, jego id jest trzymany przez drugie entity, któr¹ t¹ akcjê na nim wykonuje, entity #1 znika, jego id jest wrzucone do worka i zaraz po tym inny obiekt stworzyny dostaje jego id i akcja zostaje wykonana na innym obiekcie
	2. pozbyæ siê type_index (edit. chyba siê nie da)
	3. chyba pozby³em siê crashy w trakcie, ale za to pojawi³y siê crashe na koniec: doda³em do ka¿dego entity bool'a aktywnoœci
	4. przenios³em czêœæ wykonania akcji na skrypty, teraz tylko to usprawniæ i doprowadziæ do porz¹danego stanu
	5. nastêpny krok - przenieœæ definicje bytów do skryptów, by mo¿na stworzyæ edytor
04.06.2017
	1. utworzyæ paczki zachowañ (np. utrzymywanie przy ¿yciu, praca jako ktoœ, walka itd), które bêd¹ przekazywane konstruktorowi GoapAgenta i to bêdzie ³adne, tylko ¿e ka¿da klasa bytów musi mieæ w³asn¹ implementacjê zachowañ (np. pozyskiwanie po¿ywienia przez roœlino¿erców i miêso¿erców, mimo ¿e z zewn¹trz to bêdzie po prostu "pozyskiwanie po¿ywienia")
	2. funkcje zwracaj¹ce funkcje przy wykonywaniu akcji przez skrypty
	3. myœleæ nad wielow¹tkowoœci¹?
	4. funkcje update'uj¹ce wykonanie akcji musz¹ przyjmowaæ wykonawce, cel oraz czas, który up³yn¹³
	5. std::remove_if - dla garbage collectora
05.06.2017
	trzeba przebudowaæ tak ¿eby przerzucaæ raw pointery do Lua'y
06.06.2017
	zmieniæ g³ówn¹ pêtlê na bardziej singlow¹ ni¿ multikow¹
	logika za akcjami wrzucona ca³kowicie do skryptów, jestem ciekaw jak bêdzie z wydajnoœci¹ - ale to nie jest do koñca fajne
	dodaæ w jakiœ sposób szukanie nowych celów jeœli gonienie za aktualnym trwa za d³ugo
	no grubo HeapCorruptionException - to pewnie przez Lua'e... czasem jest to, a czasem zamyka siê ³adnie
	czy ten mój kod musi byæ taki obleœny?
	pozbyæ siê tego lagu kiedy trac¹ target
	mniej regularne checki czy cel jest nadal aktywny... to by trzeba jednak iœæ za punktem a nie Entity'em konkretnym.... to póŸnej
	dodaæ te "procedural precondition checkers"
	jakiœ wygodniejszy sposób generowania tych wrapperów - najlepiej ¿eby pomin¹æ je, a robiæ tylko w³asciwie funkcje... tylko jak wtedy z tymi zmiennymi tworzonymi we wrapperze?